<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.6">
  <POU Name="FB_BFS" Id="{ca75512e-f814-40b7-968e-2cc729017764}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_BFS
VAR_IN_OUT
	fbAdjacent : FB_AdjacentStates;
	arrTransitions: ARRAY [*, *] OF BOOL;
	arrAdjStates: ARRAY [*] OF ST_BFSAssemblyState;
	//arrAdjStates : ARRAY [*] OF DINT;
	nAdjacentStates : DINT;
	arrStates : ARRAY [*] OF ST_BFSAssemblyState;
	arrPath : ARRAY [*] OF ST_BFSAssemblyState;
	stQueue : ST_Queue;
	fbQueue : FB_Queue;
END_VAR
VAR_INPUT
	RootState : ST_BFSAssemblyState;
	Target : ST_BFSAssemblyState;
END_VAR
VAR_OUTPUT
	bError : BOOL; // an error occured, e.g. we didn't find the requested state
END_VAR
VAR
	Current : ST_BFSAssemblyState;
	Root	: ST_BFSAssemblyState;
	Adjacent : ST_BFSAssemblyState;
	iCounter : DINT;
	nStates : DINT;
	//
	iState : DINT;
	iTransition : DINT;
	bFound : BOOL := FALSE;
	Next : ST_BFSAssemblyState;
	iLower : DINT;
	iUpper : DINT;
	bFirst : BOOL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[THIS^.ClearStates();
Root := THIS^.GetState(iState:=RootState.iState, bDiscover:=TRUE); 
fbQueue.Enqueue(Root);
WHILE NOT fbQueue.Queue_Is_Empty() DO 
	Current := fbQueue.Dequeue(); 
	IF Current.iState = Target.iState THEN // found destination
		bFound := TRUE;
		EXIT;
	ELSE
		// Put adjacent states into arrAdjStates, count # of adjacent states
		THIS^.GetAdjacentStates(Current.iState); 
		// Mark any undiscovered states in arrAdjStates, add them to the queue, and label their parent state
		THIS^.DiscoverStates();
	END_IF
END_WHILE

// Stuff the target in first
//arrPath[1] := arrStates[Target.iState];
arrPath[1] := THIS^.GetState(iState:=Target.iState, bDiscover:=FALSE);
// Get the next state before starting loop
Current := THIS^.GetNextState(PrevState:=Target);
iCounter := 2;
WHILE Current.iParent <> 0 DO
	// Stuff state into path array
	arrPath[iCounter] := arrStates[Current.iState];
	// Locate the next child state
	Current := THIS^.GetNextState(PrevState:=Current);
	iCounter := iCounter + 1;
	IF iCounter >= nStates THEN
		EXIT; // Something bad happened. We exceeded the number of possible states.
	END_IF
END_WHILE

]]></ST>
    </Implementation>
    <Method Name="ClearStates" Id="{3e3c2458-8a40-4f1a-93e7-9b7fd61fb19a}">
      <Declaration><![CDATA[METHOD ClearStates : BOOL
VAR_INPUT
END_VAR
VAR
	Counter : DINT;
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR Counter := LOWER_BOUND(arrStates,1) TO UPPER_BOUND(arrStates,1) DO // set all states to undiscovered, clear parent states
	arrStates[Counter].bDiscovered := FALSE;
	arrStates[Counter].iParent := 0;
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="DiscoverStates" Id="{87a805b2-bb13-4958-a39f-73dc9e85141c}">
      <Declaration><![CDATA[METHOD DiscoverStates : BOOL
VAR_INPUT
END_VAR
VAR
	Counter : DINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR Counter := LOWER_BOUND(arrAdjStates,1) TO nAdjacentStates DO // for all adjacent states
	Adjacent := arrAdjStates[Counter];
	IF NOT arrStates[Adjacent.iState].bDiscovered THEN // check that we haven't visited this one yet
		arrStates[Adjacent.iState].bDiscovered := TRUE; // mark state as discovered
		arrStates[Adjacent.iState].iParent := Current.iState;
		fbQueue.Enqueue(arrStates[Adjacent.iState]); // add state to queue to continue search
	END_IF
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetAdjacentStates" Id="{9badcedd-7bb7-4ce3-8fa1-bcfdc713d4cf}">
      <Declaration><![CDATA[METHOD GetAdjacentStates : BOOL
VAR_INPUT
	iStartState : DINT; // Node to expand find adjacent nodes from 
END_VAR
VAR
	stateCounter : DINT;
	transitionCounter : DINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[transitionCounter := 0;
// Loop over all states to find states adjacent to the current state
FOR stateCounter := LOWER_BOUND(arrStates, 1) TO UPPER_BOUND(arrStates,1) DO // start at zero due to arrStates index
	iState := arrStates[stateCounter].iState; // pick out the state index of the state in question
	IF iState <> iStartState THEN // only look at transitions away from root state
		IF arrTransitions[iStartState, stateCounter] THEN // the transition is allowed
			transitionCounter := transitionCounter + 1;
			arrAdjStates[transitionCounter] := arrStates[stateCounter]; // save this adjacent state
		END_IF
	END_IF
END_FOR
nAdjacentStates := transitionCounter;]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetNextState" Id="{3fd28450-e405-4f2a-b7cd-70ae35b7e6ba}">
      <Declaration><![CDATA[METHOD GetNextState : ST_BFSAssemblyState
VAR_INPUT
	PrevState : ST_BFSAssemblyState;
END_VAR
VAR
	Counter : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Find next state in path by following parent attribute
FOR Counter := LOWER_BOUND(arrStates, 1) TO UPPER_BOUND(arrStates, 1) DO
	IF PrevState.iParent = arrStates[Counter].iState THEN
		GetNextState := arrStates[Counter];
		EXIT;
	END_IF
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetState" Id="{070f6607-fe71-4be9-a047-32fa70cbb954}">
      <Declaration><![CDATA[METHOD GetState : ST_BFSAssemblyState
VAR_INPUT
	iState : DINT;
	bDiscover : BOOL := FALSE; 
END_VAR
VAR
	Counter : DINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR Counter := LOWER_BOUND(arrStates,1) TO UPPER_BOUND(arrStates,1) DO
	IF arrStates[Counter].iState = iState THEN
		arrStates[Counter].bDiscovered := bDiscover; // set state to discovered
		GetState := arrStates[Counter];
	END_IF
END_FOR]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>